par(mfrow=c(1,1))
x <- beaver1$temp
hist(x, freq=F)
curve(dnorm(x),add=T)
x <- rnorm(100)
# density
hist(x,freq=F) # freq=F --> densities instead of absolute counts
# curve는 density에서 standard normal distribution 생성
curve(dnorm(x),add=T) # add=T --> overplot/overlay an existing plot
par(mfrow=c(1,1))
x <- beaver1$temp
hist(x, freq=F)
curve(dnorm(x),add=T)
hist(x, freq=T)
curve(dnorm(x),add=T)
help(curve)
hist(x, freq=T, main = "T-test for H0 : μtemp=0 vs H1 : μtemp ≠ 0",
xlab = "temp")
hist(x, freq=T, main = "T-test for H0 : μ_temp=0 vs H1 : μ_temp ≠ 0",
xlab = "temp")
curve(dnorm(x),add=T)
x <- beaver1$temp
hist(x, probability=TRUE,
main = "T-test for H0 : μ_temp=0 vs H1 : μ_temp ≠ 0",
xlab = "temp", col="lightblue")
curve(dnorm(z, mean=mean(x), sd=sd(x)), add=TRUE, col="red", lwd=2)
curve(dnorm(z, mean=mean(x), sd=sd(x)), add=TRUE, col="red", lwd=2)
curve(dnorm(x, mean=mean(x), sd=sd(x)), add=TRUE, col="red", lwd=2)
curve(dnorm(x, mean=mean(x), sd=sd(x)), add=T)
abline(v=mean(x), col="blue", lwd=2)
hist(x, probability=TRUE,
main = "T-test for H0 : μ_temp=0 vs H1 : μ_temp ≠ 0",
xlab = "temp")
curve(dnorm(x, mean=mean(x), sd=sd(x)), add=T)
abline(v=mean(x))
par(mfrow=c(1,1))
x <- beaver1$temp
hist(x, probability=TRUE,
main = "T-test for H0 : μ_temp=0 vs H1 : μ_temp ≠ 0",
xlab = "temp")
curve(dnorm(x), add=T)
abline(v=mean(x))
par(mfrow=c(1,1))
x <- beaver1$temp
hist(x, probability=TRUE,
main = "T-test for H0 : μ_temp=0 vs H1 : μ_temp ≠ 0",
xlab = "temp")
curve(dnorm(x, mean=mean(x), sd=sd(x)), add=T)
abline(v=mean(x))
help(mtext)
x <- beaver1$temp
hist(x, probability=TRUE,
main = "T-test for H0 : μ_temp=0 vs H1 : μ_temp ≠ 0",
xlab = "temp")
curve(dnorm(x, mean=mean(x), sd=sd(x)), add=T)
abline(v=mean(x))
mtext(mean(x), side=3)
help(round)
par(mfrow=c(1,1))
x <- beaver1$temp
hist(x, probability=TRUE,
main = "T-test for H0 : μ_temp=0 vs H1 : μ_temp ≠ 0",
xlab = "temp")
curve(dnorm(x, mean=mean(x), sd=sd(x)), add=T)
abline(v=mean(x))
mtext(cat(c("mean of temp: ",round(mean(x), digits = 3))), side=3)
mtext(cat(c("mean of temp: ",round(mean(x), digits = 3))), side=3)
mtext_mean <- cat(c("mean of temp: ",round(mean(x), digits = 3)))
mtext(mtext_mean, side=3)
mtext(cat(c("mean of temp: ",mean(x))), side=3)
mtext(round(mean(x), 3), side=3)
# 2. Use data frame 'state.x77'
state.x77
# 2.1. Regress 'Income' on the other variables in 'state.x77'.
# Interpret the regression results
str(state.x77)
# 2.1. Regress 'Income' on the other variables in 'state.x77'.
# Interpret the regression results
cols(state.x77)
# 2.1. Regress 'Income' on the other variables in 'state.x77'.
# Interpret the regression results
summary(state.x77)
reg.income <- lm(income ~ ., data = state.x77)
reg.income <- lm(income ~ ., data = states)
reg.income <- lm(income ~ ., data = states)
# 2.1. Regress 'Income' on the other variables in 'state.x77'.
# Interpret the regression results
states <- as.data.frame(state.x77)
reg.income <- lm(income ~ ., data = states)
# 2. Use data frame 'state.x77'
state.x77
reg.income <- lm(Income ~ ., data = states)
summary(reg.income)
# 2.2. Do the stepwise regression for this model and interpret
help(stepwise)
# 2.2. Do the stepwise regression for this model and interpret
help(step)
stepwise <- step(reg.income, direction = forward)
stepwise <- step(reg.income, direction = "forward")
stepwise
summary(stepwise)
stepwise <- step(reg.income, direction = "both")
stepwise <- step(reg.income, direction = "forward")
summary(stepwise)
stepwise <- step(reg.income, direction = "backward")
summary(stepwise)
stepwise <- step(reg.income)
summary(stepwise)
# 2.3. Do the regression diagnostics for the stepwise result
par(mfrow = c(2,2))
plot(stepwise)
# 2.4. Draw the 95% confidence bands for the expected value and the predicted value
# and the predicted value of 'Income' against given values of 'Income' with legend inside the graph
pred_conf <- predict(stepwise, interval = "confidence")
pred_pred <- predict(stepwise, interval = "prediction")
predict(lm.velo)
library(ISwR)
attach(thuesen)
is.na(thuesen)
reg.1<-lm(short.velocity~blood.glucose)
class(reg.1)
summary(reg.1)
plot(blood.glucose,short.velocity)
abline(lm(short.velocity~blood.glucose)) # draw fitted line
A<-lm(short.velocity~blood.glucose)
summary(A)
ls(A)
str(A)
A$coefficients
par(mfrow=c(1,2))
plot(blood.glucose,short.velocity)
abline(lm(short.velocity~blood.glucose))
plot(blood.glucose,short.velocity)
abline(A$coefficients[1],A$coefficients[2]) # intercept, slope
par(mfrow=c(1,1))
lm.velo <- lm(short.velocity~blood.glucose)
fitted(lm.velo)
resid(lm.velo)
dim(thuesen) # 24 observations 2 columns
thuesen=na.omit(thuesen)
dim(thuesen)
attach(thuesen)
plot(blood.glucose,short.velocity)
lines(blood.glucose,fitted(lm.velo)) # error if missing value
lm.velo <- lm(short.velocity~blood.glucose)
fitted(lm.velo)
segments(blood.glucose,fitted(lm.velo),
blood.glucose,short.velocity) # line을 starting point 부터 ending point까지만
abline(lm(short.velocity~blood.glucose)) # window의 전체에 걸쳐 line 그림
plot(fitted(lm.velo),resid(lm.velo)) # residual plot => no descinate pattern!
qqnorm(resid(lm.velo)) # normality
methods(scale) # standardize each data frame
base:::scale.default
getAnywhere(scale.default)
methods(qqnorm)
base:::qqnorm
getAnywhere(qqnorm.default)
methods(qqline)
base:::qqline
UseMethod("qqline")
getAnywhere(qqline)
qqline
capture.output(getAnywhere('qqline'), file='source_qqline.r')
getwd()
qqline(resid(lm.velo),col=3,lty=3)
segments(qnorm(0.25),quantile(resid(lm.velo),0.25),qnorm(0.75),quantile(resid(lm.velo),0.75))
length(short.velocity)
slope=(quantile(resid(lm.velo),0.75)-quantile(resid(lm.velo),0.25))/(qnorm(0.75)-qnorm(0.25))
inter=quantile(resid(lm.velo),0.25)-slope*qnorm(0.25)
abline(inter,slope)
abline(lm(sort(resid(lm.velo))~qnorm((1:23-0.5)/23)),col=2,lty=2)  # why not use this ?
predict(lm.velo)
predict(lm.velo,int="c") # narrow bands (confidence bands)
# interval="confidence" or interval="prediction",
predict(lm.velo,int="p")
pred.frame <- data.frame(blood.glucose=4:20)
pp <- predict(lm.velo, int="p", newdata=pred.frame)
pp
#### note ######
# see ?predict --> generic function, depends on the class of the 1st object
# see predict.lm
predict(lm.velo, int="p", newdata=data.frame(blood.glucose=seq(4,20,0.5)))
pc <- predict(lm.velo, int="c", newdata=pred.frame)
pc
plot(blood.glucose,short.velocity,
ylim=range(short.velocity, pp, na.rm=T))
pred.gluc <- pred.frame$blood.glucose
# 검정색 => fitted line
matlines(pred.gluc, pc, lty=c(1,2,2), col="red")  # confidence interval ()
matlines(pred.gluc, pp, lty=c(1,3,3), col="green")  # prediction interval (confidence interval for future observation)
points(pred.gluc,pc[,1], type="l",col=1)
# or
plot(blood.glucose,short.velocity,
ylim=range(short.velocity, pp, na.rm=T))
pred.gluc <- pred.frame$blood.glucose
matlines(pred.gluc, pc, lty=c(1,2,2), col="red")
matlines(pred.gluc, pp, lty=c(1,3,3), col="green")
abline(lm(short.velocity~blood.glucose))
matplot(pred.gluc, pc, lty=c(1,2,2), col='red')
predict(stepwise,int="c") # narrow bands (confidence bands)
# interval="confidence" or interval="prediction",
predict(stepwise,int="p")
pc <- predict(stepwise,int="c")
pp <- predict(stepwise,int="p")
plot(states$Income,states$Income,
ylim=range(states$Income, pp, na.rm=T),
xlab = "given income", ylab = "predicted income")
matlines(states$Income, pc, lty=c(1,2,2), col="red")  # confidence interval ()
matlines(states$Income, pp, lty=c(1,3,3), col="green")  # prediction interval (confidence interval for future observation)
points(pred.income, pc[,"fit"], type = "l", col = "black", lwd = 2)
# state.x77 데이터를 data frame으로 변환
state_data <- as.data.frame(state.x77)
# stepwise 모형을 이용한 예측 구간(pc: confidence, pp: prediction)이 이미 계산되어 있다고 가정합니다.
# 예:
pc <- predict(stepwise, interval = "confidence")
pp <- predict(stepwise, interval = "prediction")
# x축으로 사용할 'Income' 값 (여기서는 주어진 Income 값)
pred.income <- state_data$Income
# 기본 산점도: x축은 주어진 Income, y축은 실제 Income (범위는 예측 구간을 포함하도록)
plot(pred.income, state_data$Income,
ylim = range(state_data$Income, pp, na.rm = TRUE),
xlab = "Given Income", ylab = "Predicted Income",
main = "95% Confidence & Prediction Intervals for Income")
# matlines를 이용하여 95% 신뢰구간 (pc)을 빨간 선으로 그림
# 첫번째 선은 피팅된 평균값, 두번째와 세번째 선은 하한과 상한
matlines(pred.income, pc, lty = c(1,2,2), col = "red")
# matlines를 이용하여 95% 예측구간 (pp)을 녹색 선으로 그림
matlines(pred.income, pp, lty = c(1,3,3), col = "green")
# points()를 이용하여 피팅 라인(신뢰구간의 중앙값)을 검정색 선으로 강조
points(pred.income, pc[,"fit"], type = "l", col = "black", lwd = 2)
# 그래프 내부 왼쪽 상단에 범례 추가
legend("topleft",
legend = c("Fitted", "95% Confidence Interval", "95% Prediction Interval"),
col = c("black", "red", "green"),
lty = c(1,2,3),
lwd = 2)
# state.x77 데이터를 data frame으로 변환
state_data <- as.data.frame(state.x77)
# stepwise 모형을 사용한 예측 결과가 이미 아래와 같이 주어졌다고 가정합니다.
pc <- predict(stepwise, interval = "confidence")
pp <- predict(stepwise, interval = "prediction")
# 회귀 모형에서 독립변수로 사용된 예를 들어 'HS Grad'를 x축으로 사용
pred_x <- state_data$`HS Grad`
# 기본 산점도: x축은 'HS Grad', y축은 실제 Income (예측 구간의 범위를 포함하도록 ylim 설정)
plot(pred_x, state_data$Income,
ylim = range(state_data$Income, pp, na.rm = TRUE),
xlab = "HS Grad (%)", ylab = "Income",
main = "95% Confidence & Prediction Intervals for Income")
# matlines를 이용하여 95% 신뢰구간 (pc)를 빨간 선으로 그림
# 첫 번째 행은 피팅된 평균값, 두 번째와 세 번째 행은 신뢰구간 하한과 상한
matlines(pred_x, pc, lty = c(1, 2, 2), col = "red")
# matlines를 이용하여 95% 예측구간 (pp)를 녹색 선으로 그림
matlines(pred_x, pp, lty = c(1, 3, 3), col = "green")
# points()를 사용하여 피팅 라인을 검정색 선으로 강조
points(pred_x, pc[, "fit"], type = "l", col = "black", lwd = 2)
# 그래프 내부 왼쪽 상단에 범례 추가
legend("topleft",
legend = c("Fitted", "95% Confidence Interval", "95% Prediction Interval"),
col = c("black", "red", "green"),
lty = c(1, 2, 3),
lwd = 2)
pred.frame <- data.frame(blood.glucose=4:20)
pp <- predict(lm.velo, int="p", newdata=pred.frame)
pp
#### note ######
# see ?predict --> generic function, depends on the class of the 1st object
# see predict.lm
predict(lm.velo, int="p", newdata=data.frame(blood.glucose=seq(4,20,0.5)))
pc <- predict(lm.velo, int="c", newdata=pred.frame)
pc
plot(blood.glucose,short.velocity,
ylim=range(short.velocity, pp, na.rm=T))
pred.gluc <- pred.frame$blood.glucose
# 검정색 => fitted line
matlines(pred.gluc, pc, lty=c(1,2,2), col="red")  # confidence interval ()
matlines(pred.gluc, pp, lty=c(1,3,3), col="green")  # prediction interval (confidence interval for future observation)
points(pred.gluc,pc[,1], type="l",col=1)
# state.x77 데이터를 data frame으로 변환
state_data <- as.data.frame(state.x77)
# stepwise 모형을 사용한 예측 결과가 이미 아래와 같이 주어졌다고 가정합니다.
pc <- predict(stepwise, interval = "confidence")
pp <- predict(stepwise, interval = "prediction")
# 회귀 모형에서 독립변수로 사용된 예를 들어 'HS Grad'를 x축으로 사용
pred_x <- state_data$`HS Grad`
# 기본 산점도: x축은 'HS Grad', y축은 실제 Income (예측 구간의 범위를 포함하도록 ylim 설정)
plot(pred_x, state_data$Income,
ylim = range(state_data$Income, pp, na.rm = TRUE),
xlab = "HS Grad (%)", ylab = "Income",
main = "95% Confidence & Prediction Intervals for Income")
# matlines를 이용하여 95% 신뢰구간 (pc)를 빨간 선으로 그림
# 첫 번째 행은 피팅된 평균값, 두 번째와 세 번째 행은 신뢰구간 하한과 상한
matlines(pred_x, pc, lty = c(1, 2, 2), col = "red")
# matlines를 이용하여 95% 예측구간 (pp)를 녹색 선으로 그림
matlines(pred_x, pp, lty = c(1, 3, 3), col = "green")
# points()를 사용하여 피팅 라인을 검정색 선으로 강조
points(pred_x, pc[, "fit"], type = "l", col = "black", lwd = 2)
# 그래프 내부 왼쪽 상단에 범례 추가
legend("topleft",
legend = c("Fitted", "95% Confidence Interval", "95% Prediction Interval"),
col = c("black", "red", "green"),
lty = c(1, 2, 3),
lwd = 2)
state_data <- as.data.frame(state.x77)
pc <- predict(stepwise, interval = "confidence", newdata = state_data)
pp <- predict(stepwise, interval = "prediction", newdata = state_data)
df <- as.data.frame(state.x77)
hs_seq <- seq(min(df$`HS Grad`), max(df$`HS Grad`), length.out = 100)
# (4) 나머지 변수들은 평균값으로 고정
#     (stepwise 최종 모델에 포함된 변수만큼 기입; 여기서는 예시로 전부 기입)
new_data <- data.frame(
`HS Grad`   = hs_seq,
Population  = mean(df$Population),
Illiteracy  = mean(df$Illiteracy),
`Life Exp`  = mean(df$`Life Exp`),
Murder      = mean(df$Murder),
Frost       = mean(df$Frost),
Area        = mean(df$Area)
# stepwise 결과에서 빠진 변수가 있으면 해당 변수는 빼거나,
# 중간에 추가된 변수가 있으면 넣어야 합니다.
)
# (5) 새로 만든 new_data에 대해 predict()로 95% 신뢰구간, 예측구간 구하기
pc <- predict(stepwise, newdata = new_data, interval = "confidence")
pp <- predict(stepwise, newdata = new_data, interval = "prediction")
# 3. Use data frame 'mtcars'
mtcars
# 3.1. Convert variable 'wt' as a categorical variable as
# D = {0, 1, 2, 3}
quartiles <- quantile(mtcars$wt, probs = c(0.25, 0.5, 0.75))
Q1 <- quartiles[1]
Q2 <- quartiles[2]
Q3 <- quartiles[3]
mtcars$D <- cut(mtcars$wt,
breaks = c(-Inf, Q1, Q2, Q3, Inf),
labels = c("0", "1", "2", "3"),
right  = TRUE,
include.lowest = TRUE)
table(mtcars$D)
# 3.2. Fit a regression model for 'mpg' with all other variables as regressors (include 'D' instead of 'wt')
model <- lm(mpg ~ cyl + disp + hp + drat + qsec + vs + am + gear + carb + D, data = mtcars)
summary(model)
# Hyewon Jung
# 1. Use table 'UCBAdmissions' in package {IswR} in R
install.packages("ISwR")
library(ISwR)
UCBAdmissions
# 1.1. Convert this table into a data frame
df <- as.data.frame(UCBAdmissions)
df
# 1.2. Fit a binary logistic regression model for 'Admit' with regressors,
# 'Gender', 'Dept', and their interaction (This kind of data is called 'collapsed data')
# For handling collapsed data, find out how to handle this problem.
model <- glm(factor(Admit) ~ Gender+Dept+Gender*Dept, family = binomial(link='logit'), data = df)
summary(model)
# 1.2. Fit a binary logistic regression model for 'Admit' with regressors,
# 'Gender', 'Dept', and their interaction (This kind of data is called 'collapsed data')
# For handling collapsed data, find out how to handle this problem.
model <- glm(Admit ~ Gender+Dept+Gender*Dept, family = binomial(link='logit'), data = df)
summary(model)
# 1.2. Fit a binary logistic regression model for 'Admit' with regressors,
# 'Gender', 'Dept', and their interaction (This kind of data is called 'collapsed data')
# For handling collapsed data, find out how to handle this problem.
model <- glm(Admit ~ Gender+Dept+Gender*Dept, family = binomial(link='logit'), data = df, weights = Freq)
summary(model)
df
summary(model)
help(glm)
# 3. Use 'twoway2.csv' and answer the following questions. Consider the ANOVA model
# y ~ A*B
twoway2 <- read.csv("https://drive.google.com/file/d/1o1zssNL5HFvbxaPGjIeWZcCNZnCqo_0z/view?usp=sharing")
twoway2
# 3. Use 'twoway2.csv' and answer the following questions. Consider the ANOVA model
# y ~ A*B
twoway2 <- read.csv("https://drive.google.com/file/d/1o1zssNL5HFvbxaPGjIeWZcCNZnCqo_0z/view?usp=sharing", header = T)
# 3. Use 'twoway2.csv' and answer the following questions. Consider the ANOVA model
# y ~ A*B
help(read.csv)
getwd("https://drive.google.com/drive/folders/1HOos9Z5FbOuiO2n2kkvPnckIo7dGusrt?usp=sharing")
getwd("https://github.com/hw1004/data.git")
getwd("https:/github.com/hw1004/data.git")
getwd("https://github.com/hw1004/data.git")
setwd("https://github.com/hw1004/data.git")
library(RCurl)
x <- getURL("https://raw.github.com/hw1004/data.git")
x <- getURL("https://raw.github.com/hw1004/data/twoway2.csv")
twoway2 <- read.csv(text = x)
twoway2 <- read.csv(x)
twoway2 <- read.table(text = x)
twoway2 <- read.table(x)
read.table("https://raw.github.com/hw1004/data/twoway2.csv")
read.csv("https://raw.github.com/hw1004/data/twoway2.csv")
read.csv2("https://raw.github.com/hw1004/data/twoway2.csv")
url <- "https://raw.githubusercontent.com/hw1004/data/master/twoway2.csv"
twoway2 <- read.csv(url)
twoway2
# 3.1. Use the treatment coding and get Type I,III tests
contrasts(twoway2$A) = contr.treatment
# 3.1. Use the treatment coding and get Type I,III tests
contrasts(twoway2$A)
# 3.1. Use the treatment coding and get Type I,III tests
twoway2$A <- as.factor(twoway2$A)
twoway2$B <- as.factor(twoway2$B)
table(twoway2$A, twoway2$B)
model <- aov(y~A+B, twoway2)
anova(model)
contrasts(twoway2$A) = contr.treatment
contrasts(twoway2$B) = contr.treatment
contrasts(twoway2$A)
contrasts(twoway2$B)
model_treat <- aov(y~A*B, contrasts=list(A=contr.treatment, B=contr.treatment), data = twoway2)
anova(model_treat)
Anova(model_treat, type=3) # Type III test
# 3.2. Use Helmert coding and get Type I, III tests
model_helmert <- aov(y~A*B, contrasts=list(A=contr.helmert, B=contr.helmert), data = twoway2)
anova(model_helmert)
Anova(model_helmert, type=3)
# 3.3. Do the follow-up tests for A and B and A:B
library(emmeans)
model_emm <- emmeans(model_helmert, ~ A|B)
model_emm
# paired comparisons
pairs(model_helmert)
# paired comparisons
pairs(model_emm)
# 3.3. Do the follow-up tests for A and B and A:B
TukeyHSD(model_helmert)
# multiple comparison test
TukeyHSD(model_helmert)
# 3.4. Draw an interaction plot
help(within)
within(twoway2, interaction.plot(A,B,y,type = "b",pch=1:3))
# 3.4. Draw an interaction plot
help(interaction.plot)
within(twoway2, interaction.plot(A,B,y,type = "b",pch=1:3))
help(qnorm)
x=rnorm(200)
help(quantile)
Q=quantile(x,p=c(0.25,0.5,0.75), type=6)
Q
boxplot(x)
rnorm(10)
rnorm(10,7,5)
rbinom(10,20,0.5)
rbinom(10,20,0.5)
x<- rnorm(50)
mean(x)
sd(x)
var(x)
median(x)
quantile(x)  # five number summary
quantile(x,seq(0,1,0.1)) # deciles (10번 나누는 것)
seq(0,1,0.1)
library(ISwR)
data(juul)
juul
rm(list=ls())
mean(igf1) # igf one
juul
attach(juul)
mean(igf1)  # mean with missing value
length(igf1)
sum(!is.na(igf1))
sum(is.na(igf1))
igf1.1=na.omit(igf1);igf1.1
class(igf1.1)
class(igf1)
mean(igf1.1)
i1=complete.cases(igf1);i1 # missing value FALSE
igf1.n2=igf1[i1]
igf1.n2 # NA omit하고 남은 데이터들의 index 반환
summary(igf1)
summary(juul)
detach(juul)
class(juul$sex) # numeric
head(juul,22)
tail(juul,12)
juul$sex <- factor(juul$sex,labels=c("M","F"))
class(juul$sex) # factor
head(juul,22)  # NA & <NA> angle bracket
tail(juul,12)
data()
class(juul$menarche)
juul$menarche <- factor(juul$menarche,labels=c("No","Yes"))
class(juul$tanner)
table(juul$tanner)
juul$tanner <- factor(juul$tanner,
labels=c("I","II","III","IV","V"))
attach(juul)
summary(juul)
juul <- transform(juul,
sex=factor(sex,labels=c("M","F")),
menarche=factor(menarche,labels=c("No","Yes")),
tanner=factor(tanner,labels=c("I","II","III","IV","V")))
class(juul$sex)
class(juul$menarche)
x
hist(x)
x<- rnorm(50)
x
hist(x)
hist(x,breaks=7)
hist(x)
hist(x,breaks=7)
597?hist
mid.age <- c(2.5,7.5,13,16.5,17.5,19,22.5,44.5,70.5)
length(mid.age)
acc.count <- c(28,46,58,20,31,64,149,316,103)
sum(acc.count)
age.acc <- rep(mid.age,acc.count)
length(age.acc)
brk <- c(0,5,10,16,17,18,20,25,60,80)
hist(age.acc,breaks=brk)
age.acc
